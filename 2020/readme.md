# Заметки к задачам 2020 года

Это уже второй год после 2019, когда я забросил практическое велосипедостроение и начал использовать импорты.

## День 9

Поиск числа, не являющегося суммой каких-либо двух чисел из числа предыдущих 25-и, производится именно так.
Пары перебирал при помощи `itertools.combinations`.

Алгоритм второй части реализовал способом, который, на мой взгляд, дает время исполнения $O(N)$.

1. Инциируем две переменные: `i, j = 0, 1`.
   Также определим переменную-аккумулятор `sseq = nums[0]`.
2. Пока не будет найден интервал, сумма чисел в котором равна числу из первой части, повторяем:

   * если аккумулятор меньше искомого числа, то увеличиваем аккумулятор на `nums[j]`, после чего увеличиваем `j` на 1.
   * если аккумулятор больше искомого числа, то уменьшаем аккумулятор на `nums[i]`, после чего увеличиваем `i` yf 1.

В худшем случае мы должны будем два раза пробежать список чисел, по разу для `i` и `j`.

## День 10

Я не уверен, но мне кажется, что это динамическое программирование.

Решение первой части простое донельзя: сортируем список рангов и считаем разность соседних элементов, не забывая о розетке (ранг 0) и самом аппарате (ранг на 3 больше, чем максимальный ранг адаптеров).

Вторая часть решается рекурсивной функцией.
Я применил кеширование, так как, во-первых, число адаптеров (104) и небольшой шаг должны привести к переполнению стека вызовов;
и, во-вторых, малый шаг означает, что нам придется многократно находить значение функции от одного и того же аргумента.

## День 13

О, спасибо 2022 году и какой-то из задач про "диких обезьян".

В первой части нужно опреелить автобус, у которого минимальное время **до** отправления.
Это время, как несложно показать равно разности периода отправления автобуса и остатка от деления начального момента времени на этот период.

Если покрутить в голове определение остатка, то окажется, что достаточно найти остаток от деления **минус** начального момента времени на период.
Действительно, по определению $0 \leqslant r < m$, то есть при делении отрицательного числа частное будет больше, что обеспечит положительность остатка.

Во второй части понятно, что нужно решить систему следующего вида

$$\begin{align*}
x + t_1 & \equiv 0 \mod p_1 \\
x + t_2 & \equiv 0 \mod p_2 \\
& \dots \\
x + t_k & \equiv 0 \mod p_k \\
\end{align*}$$

где, по условию, $t_1 = 0$, так как первый в списке автобус уходит в момент времени $x$; $p_i$ --- периоды следования автобусов.
Эта система эквивалентна следующей

$$\begin{align*}
x & \equiv -t_1 \mod p_1 \\
x & \equiv -t_2 \mod p_2 \\
& \dots \\
x & \equiv -t_k \mod p_k \\
\end{align*}$$

Данная система имеет единственное решение с точностью до прибавления слагаемого, кратного некоторому множителю, если все $p_i$ попарно взаимно просты.
Это, по удивительному совпадению, так.
Поэтому $x$ можно найти следующим образом:

$$\begin{align*}
M & = \prod_{i=1}^k p_k \\
M_j & = \frac{M}{p_j} \\
M_j M_j^{-1} & \equiv 1 \mod p_j \ \Rightarrow\ M_j^{-1} \\
x & \equiv \sum_{j=1}^k (-t_j) M_j M_j^{-1} \mod M \\
\end{align*}$$

С учетом величины ответа, решение в лоб будет непозволительно долгим, ответ примерно равен $8.4 \times 10^{15}$!

## День 14

Установка определенного бита в определенное значение основано на логических операциях **И** и **ИЛИ**.

| Бит 0 | Бит 1 | И | Или |
|:-----:|:-----:|:----:|:----:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 |

Понятно, что для установки бита числа на 1 нужно воспользоваться побитовой операцией **ИЛИ**.
Второе число, участвующее в этом процессе, должно иметь 0 на всех позициях, кроме интересующей.

Для установки бита числа на 0 нужно воспользоваться побитовой операцией **И**.
Второе число, участвующее в этом процессе, должно иметь 1 на всех позициях, кроме интересующей.
Проще всего этого добиться при помощи создания числа с 1 на интересующей позиции с последующей его инверсией.

## День 15

Сначала решил задачу сам, решение части 2 заняло 7 секунд в `pypy` и около 15 в `python` :smile:

Потом посмотрел варианты ускорить решение на Реддите, но выяснилось, что методов ускорить нет.
Смог выиграть 1 секунду, переписав решение по образцу кода для генерирования последовательности [ван Экка](https://oeis.org/A181391).

### Обновление от 12.02.2024

Сменил словарь на список, что дало прирост в скорости в `pypy` до 1 секунды.

Сделал над собой усилие и написал программу на **Rust**, в котором решение находится менее, чем за секунду.