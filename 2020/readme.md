# Заметки к задачам 2020 года

Это уже второй год после 2019, когда я забросил практическое велосипедостроение и начал использовать импорты.

## День 9

Поиск числа, не являющегося суммой каких-либо двух чисел из числа предыдущих 25-и, производится именно так.
Пары перебирал при помощи `itertools.combinations`.

Алгоритм второй части реализовал способом, который, на мой взгляд, дает время исполнения $O(N)$.

1. Инциируем две переменные: `i, j = 0, 1`.
   Также определим переменную-аккумулятор `sseq = nums[0]`.
2. Пока не будет найден интервал, сумма чисел в котором равна числу из первой части, повторяем:

   * если аккумулятор меньше искомого числа, то увеличиваем аккумулятор на `nums[j]`, после чего увеличиваем `j` на 1.
   * если аккумулятор больше искомого числа, то уменьшаем аккумулятор на `nums[i]`, после чего увеличиваем `i` yf 1.

В худшем случае мы должны будем два раза пробежать список чисел, по разу для `i` и `j`.

## День 10

Я не уверен, но мне кажется, что это динамическое программирование.

Решение первой части простое донельзя: сортируем список рангов и считаем разность соседних элементов, не забывая о розетке (ранг 0) и самом аппарате (ранг на 3 больше, чем максимальный ранг адаптеров).

Вторая часть решается рекурсивной функцией.
Я применил кеширование, так как, во-первых, число адаптеров (104) и небольшой шаг должны привести к переполнению стека вызовов;
и, во-вторых, малый шаг означает, что нам придется многократно находить значение функции от одного и того же аргумента.

## День 13

О, спасибо 2022 году и какой-то из задач про "диких обезьян".

В первой части нужно опреелить автобус, у которого минимальное время **до** отправления.
Это время, как несложно показать равно разности периода отправления автобуса и остатка от деления начального момента времени на этот период.

Если покрутить в голове определение остатка, то окажется, что достаточно найти остаток от деления **минус** начального момента времени на период.
Действительно, по определению $0 \leqslant r < m$, то есть при делении отрицательного числа частное будет больше, что обеспечит положительность остатка.

Во второй части понятно, что нужно решить систему следующего вида

$$\begin{align*}
x + t_1 & \equiv 0 \mod p_1 \\
x + t_2 & \equiv 0 \mod p_2 \\
& \dots \\
x + t_k & \equiv 0 \mod p_k \\
\end{align*}$$

где, по условию, $t_1 = 0$, так как первый в списке автобус уходит в момент времени $x$; $p_i$ --- периоды следования автобусов.
Эта система эквивалентна следующей

$$\begin{align*}
x & \equiv -t_1 \mod p_1 \\
x & \equiv -t_2 \mod p_2 \\
& \dots \\
x & \equiv -t_k \mod p_k \\
\end{align*}$$

Данная система имеет единственное решение с точностью до прибавления слагаемого, кратного некоторому множителю, если все $p_i$ попарно взаимно просты.
Это, по удивительному совпадению, так.
Поэтому $x$ можно найти следующим образом:

$$\begin{align*}
M & = \prod_{i=1}^k p_k \\
M_j & = \frac{M}{p_j} \\
M_j M_j^{-1} & \equiv 1 \mod p_j \ \Rightarrow\ M_j^{-1} \\
x & \equiv \sum_{j=1}^k (-t_j) M_j M_j^{-1} \mod M \\
\end{align*}$$

С учетом величины ответа, решение в лоб будет непозволительно долгим, ответ примерно равен $8.4 \times 10^{15}$!

## День 14

Установка определенного бита в определенное значение основано на логических операциях **И** и **ИЛИ**.

| Бит 0 | Бит 1 | И | Или |
|:-----:|:-----:|:----:|:----:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 |

Понятно, что для установки бита числа на 1 нужно воспользоваться побитовой операцией **ИЛИ**.
Второе число, участвующее в этом процессе, должно иметь 0 на всех позициях, кроме интересующей.

Для установки бита числа на 0 нужно воспользоваться побитовой операцией **И**.
Второе число, участвующее в этом процессе, должно иметь 1 на всех позициях, кроме интересующей.
Проще всего этого добиться при помощи создания числа с 1 на интересующей позиции с последующей его инверсией.

## День 15

Сначала решил задачу сам, решение части 2 заняло 7 секунд в `pypy` и около 15 в `python` :smile:

Потом посмотрел варианты ускорить решение на Реддите, но выяснилось, что методов ускорить нет.
Смог выиграть 1 секунду, переписав решение по образцу кода для генерирования последовательности [ван Экка](https://oeis.org/A181391).

### Обновление от 12.02.2024

Сменил словарь на список, что дало прирост в скорости в `pypy` до 1 секунды.

Сделал над собой усилие и написал программу на **Rust**, в котором решение находится менее, чем за секунду.

## День 17

Сначала решил сам, программа отрабатывает за 7 секунд.

Потом воспроизвел решение [quifisto_II](https://www.reddit.com/r/adventofcode/comments/keqsfa/comment/ghbttls/),
в котором используется очень интересная оптимизация:
автор подсчитывает число соседей для всех **соседей** активных клеток.
То есть достаточно один раз пробежать по всем активным клеткам, рассматривая соседей каждой из них.
При этом сами активные клетки мы не рассматриваем, так как:

* Если у нее нет **активных** соседей, то она не войдет в словарь с числом соседей.
  Это не страшно, так как в этом случае она деактивируется по условию задачи.
* Если же у нее есть хотябы один **активный** сосед, то клетка войдет с словарь во время обработки соседей соседа.

Эта оптимизация ускоряет программу до 0.4 секунды.

## День 18

Задача, в принципе, несложная.
Подобные предлагаются практически каждый год.

Ранее решал эти задачи рекурсивным методом, так как он здесь самый очевидный: видишь скобку --- обрабатывай ее рекурсивно.
Сейчас попробовал решить задачу через линейный проход выражения с использованием **двух** вспомогательных коллекций:

* стек операций, призванный хранить операцию перед открывающей скобкой.
  Если таковой нет, например, если скобка в начале выражения или после другой открывающей скобки, то храним `None`.
* словарь из стеков значений на каждом уровне вложенности.
  Уровни определяются скобками.

Алгоритм следующий:

1. Разбиваем строку на список составляющих ее сущностей-токенов.
   Разбивать проще всего по пробелам; для этого предварительно делаем замены `"(" -> "( "` и `")" -> " )"`.
2. Начинаем обход списка токенов:
   1. если текущий токен является операцией, то сохраняем ее в переменной `op`;
   2. если текущий токен является числом, то
      * если в переменной `op` нет ничего, то есть `None`, то записываем число в стек, **соответствующий** уровню вложенности.
      * если в переменной `op` что-то есть, значит что-то есть и в стеке.
        Наши действия зависят от того, какую часть задачи мы решаем.
        В первой части мы в любом случае берем верхнее число со стека и применяем операцию к нему и текущему числу.

        Во второй мы делаем это только для сложения!
        Для умножения мы просто записывем текущее число в стек, пока игнорируя операцию.
   3. если текущий токен является открывающей скобкой, то увеличиваем счетчик вложенности на 1 и записываем операцию перед скобкой из переменной `op` в стек `ops`.
   4. если текущий токен является закрывающей скобкой, то:
      * перемножаем все значения на стеке для текущего уровня вложенности.
        Для первой части это равносильно взятию единственного числа из стека.
      * возвращаем верхнюю операцию из стека операций.
      * уменьшаем счетчик уровня вложенности на 1.
      * применяем к результату перемножение правило для токена-числа.
3. В итоге возвращаем результат перемножения значений в стеке нулевого уровня вложенности.

Полученный код выполняется на входных данных за 0.01 секунды (около 0,15 для холодного запуска).

## День 19

Решил только с помощью Реддита, не силен в регулярках и их узнавании :smile:

Преобразование правил в регулярное выражение базируется на коде [Gprinziv](https://www.reddit.com/r/adventofcode/comments/kg1mro/comment/hh7f747/).
Я его слегка упростил, не переводя числа в правилах в `int`.
Я все оставил в виде строк, просто разбив их на составные части.
Данное упрощение очень сократило функцию преобразования, снизило число `if`-ов и, на мой вкус, повысило читаемость.

Преобразование проходит в цикле, на каждом шаге список компонент будущей регулярки проходится от начала до конца до тех пор, пока в нем не остается строк, являющимися числами:

* если текущий элемент не представляет собой число (в виде текста), то переходим дальше.
* если же это число, то вместо него вставляем в список все соответствующее правило, окруженное скобками (отдельные элементы списка).

Потом все склеиваем и убираем лишние скобки.

Вторая часть основана на комментариях в решении [seattlecyclone](https://www.reddit.com/r/adventofcode/comments/kg1mro/comment/ggc24v2/).
Правило `8` превращается в `8: 42+`, так как оно, согласно условию, представяляет собой рекурсию.

С правилом `11` все сложнее, но интереснее.
[seattlecyclone](https://www.reddit.com/r/adventofcode/comments/kg1mro/comment/ggc24v2/) расширил правило, как говорится, в лоб:
`11: 42 31 | 42 42 31 31 | ...`.
Этот подход прост и работтоспособен, но ответ на моем компьютере находится секунд за 20.

Но в одном из комментариев к [seattlecyclone](https://www.reddit.com/r/adventofcode/comments/kg1mro/comment/ggc24v2/) было сказано, что в Perl есть **рекурсивные образцы**!
Есть они и в Python, но не в стандартном пакете `re`, а в нестандартном `regex`.
С их использованием правило преобразуется к виду:
`11: (?<Z>42 <?&Z>* 31)`.
Решение находится за 0.3 секунды!
