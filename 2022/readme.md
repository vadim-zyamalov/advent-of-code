# Заметки к задачам 2022 года

## День 11

Ух, вот я и полез в Reddit :)

Первая часть простая, самая длинная часть кода --- разбор списка
обезьян и запись его в словаре.

Вторая часть хитрая. Очень. Показывает, что мне, наконец (!) надо
изучить дисретную математику на базовом уровне, в частности работу с
модулями (вычетами). Плохо у меня с математикой :(

## День 12

Традиционная задача на алгоритм Дейкстры. Всего 2 реализации: первая
ищет кратчайший путь от старта ДО финиша. Вторая ищет кратчайший путь
ОТ финиша до КАЖДОЙ точки карты.

Как ни странно, вторая реализация работает в два раза быстрее для
первой части и в 150 раз для второй части задачи. Причина --- вторая
реализация сразу рассчитывает все пути для всех точек, что избавляет
от необходимости дублировать все расчеты.

P.S. Попробовал разобраться с `heapq`, в этот раз (в отличие от прошлого
года) это у меня даже получилось.
`heapq` дал какой-то жуткий рост производительности. Надо взять его на заметку!

## День 13

Господа, это позор и опа :) Не совсем полная, но тем не
менее. Пришлось подсмотреть решение на reddit.

Мое решение, в общих
чертах, было написано в том же ключе, что и подсмотренное, но не
работало :) На самом деле, я допустил ошибку в логике написания
рекурсивной функции:

1. В первую очередь надо описывать и обрабатывать все (!) пути выхода из
рекурсии, и лишь потом вводить ее саму.
2. Рекурсию можно запускать не только для вложенных структурных
объектов тиа списков внутри списков, но и вообще для любого типа.

Я допустил две вышеприведенные ошибки, в реультате чего упустил один
из вариантов развития событий --- пустой левый элемент.

Заодно узнал, как создавать собственные функции для сравнения и сортировки.

## День 16

Нууу... Как-то так. На самом деле, основную идею я придумал еще
утром. Алгоритм Дейкстры просится. Но, к сожалению, я не смог додумать
правильную реализацию хранения состояний.

Я сам дошел до идеи, что нам
не нужны узлы с бесполезными вентилями, и что можно просто построить
НОВЫЙ граф, только со стартовым узлом АА и узлами со значащими
вентилями.

Также я сам написал алгоритм для поиска расстояний в перестроенном
графе.

Но вот в основном алгоритме я немного просел. Я пытался хранить
состояние в виде 4 значений: время --- аналог расстояния, счет ---
сброшенное давление, текущий узел и кортеж с состоянием узлов ---
посещен/не посещен. Но реализация оказалась слишком сложной, где-то в
ней сидела ошибка.

[Следующий комментарий на Reddit](https://www.reddit.com/r/adventofcode/comments/zn6k1l/comment/j0glv1y) помог мне переписать мою функцию.
Она стала несколько проще. Теперь мне нужно хранить только 3 значения:
время, счет и список с ПУТЕМ! Это оказалось и проще, и было нужно на
втором этапе.

Второй этап я прямо списал. Но логику, все-таки, понял.

Нууу... Как-то так. Не очень результат :)

## День 17

[Я все равно полез в Reddit](https://www.reddit.com/r/adventofcode/comments/znykq2/comment/j0kdnnj), так как не смог сам додумать принцип
кеширования состояний в задаче. Но основную часть решил сам. Вторая часть задачи моим способом бы тоже решилась, но за несколько часов.

## День 18

[Подсмотрел](https://www.reddit.com/r/adventofcode/comments/zpihwi/comment/j0tgt4d/), как надо было сокращать число проверяемых
состояний. Обычный алгоритм Дейкстры сыпался уже на тестовых данных,
работал крайне долго.

Решение, строго говоря, заключалось в обновлении и обрезании очереди в
каждую минуту.

## День 20

Простая задача с хитрым решением. Надо было просто немного подумать над
расчетом нового индекса и тем, как использовать его для обновления
последовательности.

1. Движение элемента по закольцованной последовательности можно описать
   его движением по другой закольцованной последовательности, состоящей
   из ПРОМЕЖУТКОВ между элементами исходной последовательности, из
   которой убрали рассматриваемый элемент. Длина такой
   последовательности, учитывая, что пустое место за последним элементом
   эквивалентно пустому месту перед первым, на единицу меньше.
2. Расчет точного места вставки элемента зависит от того, сдвинется ли
   он в итоге вправо или влево.

P.S. Все еще проще, проверки на сдвиг вправо-влево не нужны. Нужно было
внимательнее посмотреть на самим собой нарисованную схему.
Надо просто сначала удалить елемент из массива, а потом вставить его по
новому адресу.

## День 23

Задачу решил сам, а вот способ сделать это быстро подсмотрел на reddit.
Честное решение первой части занимало около 7,5 секунд, второй ---
молниеносные 1300-1400 секунд.

Подсмотренная оптимизация привела к 0,19 и 10 секундам, соответственно.

Действительно, одиноких эльфов, не имеющих соседей, можно сразу
пропускать. На первых циклах это неважно, но ближе к концу, когда
большинство эльфов перестают двигаться, это очень ускоряет процесс.

Также узнал для себя о коллекции Counter. Она делает то, что я делал при
помощи словаря. Подозреваю, что он быстрее.

И я отказался от бесконечного создания списков и перешел к изменению
единственного множества. Это СУЩЕСТВЕННО сократило время работы.

## День 24

Гребаный стыд. Я, честное слово, не понимаю, что было не так. Я раз 50
перепроверил код, он должен был работать (и на тестовом примере он
работал).

Но на основных данных он выдавал неверный ответ!!! Я долго и мучительно
пытался найти ошибку, потом долго сравнивал свое решение с одним из
таковых на Reddit; я даже переделал свой код по аналогии! Фигвам,
индейская национальная изба.

Утром, после ПОЛНОГО перенесения логики решения с Reddit на мой код. Он
заработал. И даже возврат к моей логике этому не помешал!!!

ЧТЯДНТ!!!
