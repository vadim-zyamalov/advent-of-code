# Заметки к задачам 2021 года

## День 14

Несколько важных уроков, которые стоит извлечь из решения этой не самой сложной задачи:

* Внимательно читаем условие.
  Если сам автор пишет, что длина чего-то растет экспоненциально, то имеет смысл предположить, что решение "в лоб" будет неоптимальным как минимум.
  А как максимум, оно забьет всю память и будет глумливо хихикать.
* Внимательно смотрим на исходные данные и на пример (если он у вас, конечно, есть).
  Путь к упрощению решения задачи, или к более оптимальному варианту, может крыться в условиях.
* И думаем над логикой до написания кода :smile:

Приведено два правильных решения, одно из которых требует мейнфрейма с over 9000 RAM, а второе работает за доли секунды.

## День 15

Да, да, признаюсь, я -- не программист, CS мне не преподавали
(точнее то, что преподавали, на полноценное CS не тянет, только на
введение в тему). Так что вторую часть я подсмотрел.

На самом деле, хорошо, что подсмотрел. Без этого я бы алгоритм Дейкстры
не понял так как все описания, что я видел до этого, отличались "умом и
сообразительностью". Другими словами они с места в карьер начинали
описывать быстрый и оптимизированный метод, включающий очереди и тому
подобные изыски.

Тем не менее, применение алгоритма Дейкстры в классическом варианте (с
удалением вершин) для данной задачи неэффективно из-за числа точек (2,5
миллионов). [На странице в Википедии](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Using_a_priority_queue) и в [посте на Reddit](https://www.reddit.com/r/adventofcode/comments/rgqzt5/comment/hon7qbz)
приведен вариант для добавления точек, что эффективнее, так как не
требует постоянного поиска минимального значения в списке расстояний (у
нас суммы весов) длиной те же 2,5 миллиона.

Хотя вторую звездочку я списал, но зато разобрался с алгоритмом
Дейкстры.

## День 17

Долго не мог понять, как все делать. Почему оно не работает,
БЛДЖАД!!! Я не знаю, специально так задумано, или это так удачно
случайно получилось, но ма-а-аленькая особенность, важная для решения
первой части, не давала получить правильный ответ во второй.

Отчаявшись, я пошел читерить, но это мне не помогло, все решали задачу
брутфорсом. Решил и я запилить свой. Пока писал -- нашел вышеупомянутую
особенность, что разом исправило проблему.

И еще один урок: не быть самонадеянным и гонять код сначала на ПРИМЕРЕ,
БЛДЖАД!!!

## День 18

Задача с первых строк зудит: "Пиши парсер! Пиши-и-и парсер".
Возможно, что более сведущие в программировании товарищи смогут
реализовать решение через парсер, но я столкнулся с непониманием того,
как выявлять "самый левый" элемент, удовлетворяющий критериям. Мне
оказалось проще оперировать с исходной строкой.

P.S. Хотя парсер я таки написал и в коде он сохранился. Для истории.

P.P.S. Посмотрел выпуск "Tsoding Daily" про эту задачу, и мне пришла мысль,
как применить деревья для решения. Super easy!

## День 22

Интересная задача. Решение в лоб приводит к экспоненциальному росту
и забиванию памяти. А решение через явное разрезание кубов работает за
секунды, даже в питоне, который считается медленным языком.

P.S. [Здесь](https://www.youtube.com/watch?v=YKpViLcTp64) лежит чудесное видео с другим методом решения задачи.
Очень полезно!

## День 24

Задача хитрая (для меня), я ее честно подрезал на реддите... Не, мое
решение, конечно, верное, и когда-нибудь оно точно найдет ответ. В итоге,
первый вариант (мой) отпадает.

Второй вариант -- рекурсия с реддита, работет 10 минут на моем железе,
что терпимо.

И, наконец, третий вариант, идею которого я также увидел на реддите.
Штош, надо учиться анализировать код типа ассемблера и писать его
эквиваленты, а также прокачивать скилл распознавания задач на системы
счисления и стеки. Работает менее секунды.

Опрадания ради написал парсер для третьего варианта, который делвет
возможным решение любой задачи этого дня.
