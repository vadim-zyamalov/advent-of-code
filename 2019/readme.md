# Заметки к задачам 2019 года

## День 4

Решение, подсмотренное на Реддите.

Важный урок, который я должен был уже давно усвоить: иногда решение в лоб является наиболее оптимальным!

Я попытался решить задачу комбинаторным путем, но столкнулся с тем, что возникает необходимость учета огромного числа неочевидных дубликатов.
Свой код оставил на память...

### Обновление от 20.01.2024

Свой *старый код* выбросил, так как все-таки смог реализовать комбинаторное решение.
Интересно то, что после первой неудачи я просматривал свои решения прошлых годов и наткнулся на 15 день 2015 года.

В этой задаче требовалось изготовить какое-то варево с применением ровно 100 ложек четырех ингредиентов.
Мой старый код работал довольно медленно, но работал.
После мучений с комбинаторикой в 04/2019 я легко переписал код распределения ложек между ингредиентами, ускорив работу раз в 500 (по моим прикидкам в уме).

Забавно то, что это новое решение и натолкнуло меня на комбинаторное решение текущей задачи.

По сути, что нам надо сделать.
У нас есть $N$ цифр-позиций (6, но может быть и меньше).
В эти позиции надо разместить цифры из набора размера $K$ (от какого-то начального до 9).
Эта задача эквивалентна задаче размещения $N$ идентичных шаров по $K$ упорядоченным коробкам, которая решается методом "шаров и перегородок".

Суть метода в том, что содержимое каждой "коробки" отделяется от других "коробок" перегородками.
Всего нам нужно разместить $K-1$ перегородку.
Объединим шары и перегородки в единый набор сущностей, после чего найдем число сочетаний $C_{N+K-1}^{K-1}$, то есть число способов выбрать $K-1$ перегородку из совокупности шаров-перегородок.

Функция `num` делает как раз именно это:

1. В функции происходит перебор всех вариантов размещения перегородок, для каждого из которых находится число шаров в соответствующей коробке.
   Для упрощения цикла подсчета (для устранения граничных случаев для первого и последнего элементов) к рассматриваемому на каждом шаге набору позиций добавляются $-1$ и $N$ в начале и конце, соответственно.
2. Полученный набор проверяется на соответствие условию правильности пароля `cond`.
   По умолчанию это наличие хоть одной цифры, которая встречается не менее 2 раз.
   Неубывание цифр проверять не нужно, так как оно обеспечивается построением ("коробки" упорядоченны).

Можно было бы захардкодить начальные и конечные границы для пароля, но это не наш метод.
Функция `count` вычисляет число валидных паролей от какого-то числа до 999999 (аргумент `digits` позволяет варьировать длину пароля).

1. Сначала мы разбираем число на цифры.
   Опять-таки, для избавления от граничных случаев добавляем в конец псевдо-цифру 9.

   * Если число цифр в числе меньше целевого, то просто возвращаем число паролей от 111111 до 999999.
   * Если больше - возвращаем 0.
     Очевидно, что валидных 6-значных паролей, начинающихся с 7-значного начального значения, не так уж и много.

2. Далее создаем пустой стек и начинаем анализировать цифры.

   * Если текущая цифра $d_0$ меньше или равна следующей (например $2\ 7****$), то запишем в стек кортеж из $d_0+1$ и числа цифр-позиций от текущей цифры до конца числа включительно.
     Это означает, что $d_0$ фактически зафиксирована следующей цифрой $d_1$, поэтому число валидных паролей равно числу валидных паролей длиной на единицу меньше (фактически мы фиксируем первую цифру и перебираем последующие), которое мы определим на следующем шаге, плюс числу валидных паролей текущей длины, но начинающихся с цифры $d_0+1$ (например $3*****$).
   * Если же $d_0$ **больше** $d_1$, то записываем в стек кортеж из $d_0$ и текущей длины и прекращаем разбор.
     Дальнейший разбор не нужен, так как первый валидный пароль $d_0\ d_0 \dots d_0$ уже больше, чем рассматриваемый хвост числа.
   * Если мы не остановили разбор, то есть реализовалась первая ситуация, то переходим к следующей цифре $d_1$.
     Длина рассматриваемого отрезка, хвоста числа, уменьшается на 1.

3. После заполнения стека последовательно возвращаем верхнее значение, получаем из него первую цифру диапазона (от этой цифры до 9), число цифр-позиций.
   После чего считаем число валидных паролей функцией `num` и прибавляем к аккумулятору.
   Повторяем до исчерпания стека.

Итоговый ответ равен разнице числа валидных паролей от начала диапазона и от его конца.
Напомним, функция `count` считает число паролей до 999999.

## День 14

Залез на Реддит только для того, чтобы убедиться, что мое решение было правильным.

Но с ошибкой :smile:

Собака была зарыта в попытке сделать функцию способной быть примененной в цепном вызове,
то есть когда вывод предыдущего вызова передавался на вход следующего.
Для этого одному из аргументов функции задавалось значение по умолчанию `defaultdict(int)`.

Все бы хорошо, но я внезапно вспомнил, что значения по умолчанию инициализируются на в момент вызова функции,
что приводило бы к пересозданию **мутабельного** объекта, а в момент создания объекта функции,
что происходит во время обработки ее кода.
То есть все вызовы функции оперируют **одним и тем же объектом**!

То есть в моем случае вместо пустого словаря в функции болтался какой-то мусор.
После исправления ошибки все пошло как по маслу.

Логика первой части проста, но заковыриста.
Мы отслеживаем объемы производства каждого из ингредиентов и остающиеся излишки.
Излишки возникают по причине того, что мы не всегда можем произвести нужное количество за целое число реакций.

Создадим

* словари для объемов производства и излишков;
* очередь для обработки объемов производства.

Запишем в очередь кортеж `("FUEL", n)`, где `n` --- нужное количество топлива.
Пока очередь не пуста, повторяем следующую процедуру:

1. Забираем из очереди первый элемент: ингредиент и его необходимое количество `V`.
   Так как один ингредиент может участвовать в разных реакциях, то он может попадать в очередь несколько раз.
2. Если ингредиентом является руда, то просто увеличивем объемы производства в соответствующем словаре на `V` и переходим к пункту 1.
2. Вычитаем из `V` объемы излишков данного ингредиента (они могут быть если мы ранее уже производили данный ингредиент).
   Находим частное и остаток от деления полученного объема на объем производства ингредиента в соответствующей реакции.
3. Если остаток

   * равен нулю, значит мы можем произвести целым числом реакций объем `V` за вычетом излишков.
     Приравняем излишки нулю.
   * больше нуля, то увеличиваем частное на 1, так как нам понадобится дополнительная реакция для произодства данного остатка.
     Излишки приравняем к объему производства (произведению частного на объем производства в реакции) за вычетом требуемого объема производства, уменьшенного на величину излишков.

4. После чего последовательно добавляем в очередь кортежи из названий новых ингредиентов (берем из реакции для производства текущего) и их требуемых объемов, умноженных на частное из пункта 2.
   Увеличиваем объемы производства ингредиента в соответствующем словаре на произведение частного из пункта 2 на объем производства в реакции.

После опустошения очереди возвращаем из словаря объемов производства значение для руды.

Во второй части воспользуемся методом, близким по духу к [методу Ньютона](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%9D%D1%8C%D1%8E%D1%82%D0%BE%D0%BD%D0%B0).
Отметим, что из-за наличия излишков, $Ore(N) \leqslant N \times Ore(1)$, где $Ore(N)$ --- минимальный объем руды для производства $N$ единиц топлива.
Алгоритм следующий.

1. Найдем $Ore(1)$ и используем это значение для получения нижней границы ответа $$N_0 = \lfloor Ore_{max} / Ore(1) \rfloor$$
   Эта граница будет заведомо меньше правильного результата.
   Примем $N_0$ в качестве начального значения.
2. Найдем $Ore(N_i)$.

   * Если это значение будет больше, чем $Ore_{max}$, то ответом будет $N_{i-1}$.
   * Иначе найдем разницу
     $$\Delta Ore = Ore_{max} - Ore(N_i)$$
     целочисленно разделим ее на $Ore(1)$
     $$\Delta N = \lfloor \Delta Ore / Ore(1) \rfloor$$
     и увеличим $N$ на полученный результат или на 1, если он равен нулю
     $$N_{i+1} = N_i + \max \{\Delta N, 1\}$$

## День 16

Первая часть довольно простая, но нужно аккуратно работать с индексами.

Вторая часть гораздо сложнее. Я ее решил только с помощью Реддита.
У меня в мозгу появлялась идея матриц, но я ее обдумывал в неправильном направлении.

Решение основывается на той идее, что величина смещения в данных заведомо переводит нас во вторую половину длинного числа (исходное число, повторенное 10000 раз).
А если проанализировать правило, по которому происходит суммирование, то станет ясно, что все цифры во второй половине числа строятся на основании паттерна, состоящего из нулей в начале (вплоть до позиции искомой цифры) и единиц после (вплоть до конца числа).

Собственно, это все объяснение решения.

## День 18

Я задачу и решил, и не решил.

Первая часть довольно простая и представляет собой алгоритм Дейкстры, где в качестве состояния надо хранить позицию и набор найденных ключей.

Вторая часть, строго говоря, тоже представляет собой алгоритм Дейкстры, в котором теперь надо хранить четыре позиции и список ключей.
В остальном, в принципе, все то же самое.

Кроме того факта, что работает все адски медленно.
Я поставил эту задачу решаться на ночь, но компьютер ушел в гибернацию **до** получения ответа.
Причем после пробуждения я обнаружил, что программа забила всю память!
Хотя, справедливости ради, на маленьких примерах все работает.
Видимо размер реальной задачи требет оптимизации.

Идею подсмотрел у [u/bla2](https://www.reddit.com/r/adventofcode/comments/ec8090/comment/fbdtmks/).
Смысл ее в том, что кратчайший путь мы так же ищем при помощи алгоритма Дейкстры, причем более-менее таким же, что и у меня.
Единственное, но существенное отличие состоит в том, что в нем мы ходим не по одной клеточке, а сразу между ключами!
Для этого используется функция-генератор, которая последовательно возвращает все достижимые из текущего состояния ключи.
Используется обход в ширину, что дает нам какой-нибудь **кратчайший** путь до каждого достижимого ключа.

# День 19

Задача довольно простая.

Первую часть решил простым перебором всех координат.
Думаю, что можно использовать вторую часть для ускорения (да, можно, работает гораздо быстрее).

Во второй части я строил словарь, где для каждого значения `y` сохранял левую (включительно) и правую (не включительно) границы луча.
После чего просто проверял допустимость координат `x0` и `x1` для `y` и `y-99` соответственно.

# День 20

Задача несложная, если сразу догадаться, как хранить данные, и как сократить задачу.
Подход похож на задачу **23/2023**: надо заменить лабиринт более простой структурой с меньшей размерностью.

По аналогии с **23/2023** я заменил лабиринт на граф, узлами которого являются вход, выход и все перекрестки.
Перекресток --- это доступная клетка, к которой примыкает **более двух** доступных клеток.
Замечу, что порталы не являются узлами графа; я рассматривал их просто как разрыв в коридоре, переходя к соответствующей клетке при помощи списка порталов.

Для первой части этого достаточно.
Построив граф при помощи поиска пути от одного узла к другому, можем скормить его алгоритму Дейкстры, причем самому базовому.

Для второй части понадобилось дополнительно разделить единый список порталов на два: внешние и внутренние.
Также для каждого пути между узлами, которых может быть несколько, сохраняем суммарное изменение уровня бублика и **минимальное** значение этого изменения.
Минимальное значение нужно для того, чтобы мы не перешли в отрицательные уровни, что невозможно, так как на нулевом уровне внешние порталы являются стенами.
В алгоритме Дейкстры теперь хранится не только узел, но и уровень бублика.

То, что число путей между узлами может быть больше одного, явно следовало из **первого** примера, но для первой части это не было существенным.
А вот во второй внезапно стало!

# День 21

Задача проста для реализации, но сложна для решения.

Мои программы для роботов работают и дают правильный ответ, но я не уверен, что эта задача вообще имеет общее решение.

# День 22

Очередная задача, которая ясно показала, что мне не хватает математического образования :disappointed:
Первая часть была простой, решалась в лоб.
А вот вторая...

Нет, основные идеи у меня в голове были.

* Я, глядючи на "веселые" числа, сразу понял, что решение в лоб --- не вариант.
  Нет, я, ради интереса, конечно запустил его, для одной тасовки, но я и так понял, что все не так просто.
* У меня была идея, что неплохо бы построить отношение между конечными индексами и начальными, но в голову лезли только словари.
  А количество карт показывало, что проще решать в лоб :smile:

На Реддите в посте [u/metalim](https://www.reddit.com/r/adventofcode/comments/ee0rqi/comment/fbwauzi/) я нашел решение, которое помогло мне понять, что же имели в виду другие комментаторы, когда говорили о полиномах и модульной арифметике.

Опишу свое понимание решения.

Основная идея --- представить индексы карт (в начале совпадающие с их значениями) и их преобразования в виде некоторого полинома, взятого по модулю
$$x = a x_0 + b \bmod N$$
где $x_0, x$ --- исходный и конечный индексы, $N$ --- размер колоды, $a, b$ --- какие-то коэффициенты.
Очевидно, что для индексов **до** перобразований $a = 1,\ b = 0$.

Каждое преобразование что-то делает с коэффициентами этого полинома:

1. перекладывание колоды в новую стопку, как не трудно убедиться, эквивалентно отражению колоды в обратном порядке.

   Пусть текущий индекс равен $x = a x_0 + b \bmod N$.
   Тогда можно показать, что после преобразования полином примет вид
   $$\hat{x} = -a x_0 + (N - b - 1) \bmod N$$
   Действительно, пусть искомый полином равен $\hat{x} = \hat{a} x_0 + \hat{b} \bmod N$.
   Также очевидно, что при инверсии $\hat{x} = N - x_0 - 1 \bmod N,\ \forall x$.

   Тогда, взяв $x_0 = 0$, получим
   $$\hat{b} \bmod N = N - b - 1 \bmod N$$
   А взяв $x_0 = 1$, получим
   $$\hat{a} + \hat{b} \bmod N = N - a - b - 1 \bmod N = -a + \hat{b} \bmod N$$
   из чего следует
   $$\hat{a} \bmod N = -a \bmod N$$
2. перенос части колоды из начала в конец и наоборот.
   В терминах полинома это эквивалентно вычитанию заданного числа карт из $b$.

   Действительно, очевидно, что
   $$\hat{x} = x_0 - n \bmod N,\ \forall x$$
   откуда при $x_0 = 0$ следует
   $$\hat{b} \bmod N = b - n \bmod N$$
3. раскладывание с шагом.
   Самая хитрая процедура.
   Строго говоря, в общем случае это раскладывание в том виде, в котором оно описано в задаче, не получится.

   Но в том же условии дан жирный намек на то, что шаг раскладывания и длина колоды являются взаимно простыми.
   Это гарантирует, что мы пройдем все позиции.

   Формула для изменения полинома имеет вид
   $$\hat{x} = n x \bmod N = a n x_0 + n b \bmod N,\ \forall x$$
   Отсюда имеем
   $$\hat{b} = n b \bmod N$$
   $$\hat{a} = n a \bmod N$$

Для решения задачи нам нужно получить правила обратных операций с колодой:

1. перекладывание колоды (инверсия) является обратной для самой себя.
2. обратной операцией к переносу части колоды является перенос той же части, но в обратном направлении.
3. с раскладыванием с шагом все посложнее.
   Здесь важным фактором является взаимная простота шага раскладывания и длины колоды.
   Это позволяет найти обратное по модулю значение к $n$.

   Поиск можно производить по разному.
   В `Python` можно воспользоваться функцией `pow`:

   ```python
pow(n, -1, N)
   ```

   Или применить малую теорему Ферма, так как, внезапно, число карт является простым числом.

   ```python
pow(n, N-2, N)
   ```

   Или расширенный алгоритм Евклида, рассчитывающего, помимо НОД, еще и коэффициенты соотношения Безу.
   Для взаимно простых чисел эти коэффициенты являются обратными по модулю соответствующего числа по модулю другого.

   ```python
def extended_gcd(a, b):
    s0, s1, t0, t1 = 1, 0, 0, 1
    while b:
        q, r = divmod(a, b)
        a, b = b, r
        s1 = s0 - q * s1
        t1 = s0 - q * t1
    return a, s1, t1
   ```

После того, как обращением всех действий **в обратном порядке** был получен полином, связывающий коечный индекс с начальным, надо возвести его в степень, равную числу повторения тасовки.

Возведение в лоб непродуктивно, так как даже если даже переписать полином в виде общей формул, нам нужно будет возводить большое число в еще более большую степень.
Поэтому лучше использовать рекурсивное возведение в степень.

Для этого отметим, что
$$f(x) = a x + b \bmod N$$
$$g(x) = c x + d \bmod N$$
$$f^2(x) \coloneqq (f \circ f)(x) \coloneqq f(f(x)) = a^2 x + a b + b \bmod N$$
$$(g \circ f)(x) \coloneqq g(f(x)) = a c x + c b + d \bmod N$$
С учетом этих формул можем реализовать следующий алгоритм:

1. Если степень равна 1, то возвращаем $a$ и $b$.
2. Если степень четная, то возвращаем результат возведения полинома $f^2(x)$ во в два раза меньшую степень.
3. Если степень нечетная, то возвращаем результат применения полинома к нему же, но возведенному в степень на единицу меньше.

В итоге подставляем в получившийся полином индекс из условия и получаем искомое значение.

# День 24

Задача простая, но 2 часа искал ошибку, что не очень понравилось :smile:

# День 25

Задача забавная.

Сначала решил поиграть и получить удовольствие, но что-то пошло не так :)

Пришлось, по заветам Реддита, где большинство писало, что реализовывало автоматического игрока, городить кошмар из двух BFS...

В CPython ответ находится за 25-30 секунд, в pypy3 --- за 6.
Есть кусок хардкода, но городить дополнительную проверку не хоцца.

Вообще это можно сделать, но там есть такая штука, как `infinite loop`...
Его **точно** надо хардкодить...
