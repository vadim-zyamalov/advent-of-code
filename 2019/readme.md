# Заметки к задачам 2019 года

## День 4

Решение, подсмотренное на Реддите.

Важный урок, который я должен был уже давно усвоить: иногда решение в лоб является наиболее оптимальным!

Я попытался решить задачу комбинаторным путем, но столкнулся с тем, что возникает необходимость учета огромного числа неочевидных дубликатов.
Свой код оставил на память...

### Обновление от 20.01.2024

Свой *старый код* выбросил, так как все-таки смог реализовать комбинаторное решение.
Интересно то, что после первой неудачи я просматривал свои решения прошлых годов и наткнулся на 15 день 2015 года.

В этой задаче требовалось изготовить какое-то варево с применением ровно 100 ложек четырех ингредиентов.
Мой старый код работал довольно медленно, но работал.
После мучений с комбинаторикой в 04/2019 я легко переписал код распределения ложек между ингредиентами, ускорив работу раз в 500 (по моим прикидкам в уме).

Забавно то, что это новое решение и натолкнуло меня на комбинаторное решение текущей задачи.

По сути, что нам надо сделать.
У нас есть $N$ цифр-позиций (6, но может быть и меньше).
В эти позиции надо разместить цифры из набора размера $K$ (от какого-то начального до 9).
Эта задача эквивалентна задаче размещения $N$ идентичных шаров по $K$ упорядоченным коробкам, которая решается методом "шаров и перегородок".

Суть метода в том, что содержимое каждой "коробки" отделяется от других "коробок" перегородками.
Всего нам нужно разместить $K-1$ перегородку.
Объединим шары и перегородки в единый набор сущностей, после чего найдем число сочетаний $C_{N+K-1}^{K-1}$, то есть число способов выбрать $K-1$ перегородку из совокупности шаров-перегородок.

Функция `num` делает как раз именно это:

1. В функции происходит перебор всех вариантов размещения перегородок, для каждого из которых находится число шаров в соответствующей коробке.
   Для упрощения цикла подсчета (для устранения граничных случаев для первого и последнего элементов) к рассматриваемому на каждом шаге набору позиций добавляются $-1$ и $N$ в начале и конце, соответственно.
2. Полученный набор проверяется на соответствие условию правильности пароля `cond`.
   По умолчанию это наличие хоть одной цифры, которая встречается не менее 2 раз.
   Неубывание цифр проверять не нужно, так как оно обеспечивается построением ("коробки" упорядоченны).

Можно было бы захардкодить начальные и конечные границы для пароля, но это не наш метод.
Функция `count` вычисляет число валидных паролей от какого-то числа до 999999 (аргумент `digits` позволяет варьировать длину пароля).

1. Сначала мы разбираем число на цифры.
   Опять-таки, для избавления от граничных случаев добавляем в конец псевдо-цифру 9.

   * Если число цифр в числе меньше целевого, то просто возвращаем число паролей от 111111 до 999999.
   * Если больше - возвращаем 0.
     Очевидно, что валидных 6-значных паролей, начинающихся с 7-значного начального значения, не так уж и много.

2. Далее создаем пустой стек и начинаем анализировать цифры.

   * Если текущая цифра $d_0$ меньше или равна следующей (например $2\ 7****$), то запишем в стек кортеж из $d_0+1$ и числа цифр-позиций от текущей цифры до конца числа включительно.
     Это означает, что $d_0$ фактически зафиксирована следующей цифрой $d_1$, поэтому число валидных паролей равно числу валидных паролей длиной на единицу меньше (фактически мы фиксируем первую цифру и перебираем последующие), которое мы определим на следующем шаге, плюс числу валидных паролей текущей длины, но начинающихся с цифры $d_0+1$ (например $3*****$).
   * Если же $d_0$ **больше** $d_1$, то записываем в стек кортеж из $d_0$ и текущей длины и прекращаем разбор.
     Дальнейший разбор не нужен, так как первый валидный пароль $d_0\ d_0 \dots d_0$ уже больше, чем рассматриваемый хвост числа.
   * Если мы не остановили разбор, то есть реализовалась первая ситуация, то переходим к следующей цифре $d_1$.
     Длина рассматриваемого отрезка, хвоста числа, уменьшается на 1.

3. После заполнения стека последовательно возвращаем верхнее значение, получаем из него первую цифру диапазона (от этой цифры до 9), число цифр-позиций.
   После чего считаем число валидных паролей функцией `num` и прибавляем к аккумулятору.
   Повторяем до исчерпания стека.

Итоговый ответ равен разнице числа валидных паролей от начала диапазона и от его конца.
Напомним, функция `count` считает число паролей до 999999.
