# Заметки к задачам 2019 года

## День 4

Решение, подсмотренное на Реддите.

Важный урок, который я должен был уже давно усвоить: иногда решение в лоб является наиболее оптимальным!

Я попытался решить задачу комбинаторным путем, но столкнулся с тем, что возникает необходимость учета огромного числа неочевидных дубликатов.
Свой код оставил на память...

### Обновление от 20.01.2024

Свой *старый код* выбросил, так как все-таки смог реализовать комбинаторное решение.
Интересно то, что после первой неудачи я просматривал свои решения прошлых годов и наткнулся на 15 день 2015 года.

В этой задаче требовалось изготовить какое-то варево с применением ровно 100 ложек четырех ингредиентов.
Мой старый код работал довольно медленно, но работал.
После мучений с комбинаторикой в 04/2019 я легко переписал код распределения ложек между ингредиентами, ускорив работу раз в 500 (по моим прикидкам в уме).

Забавно то, что это новое решение и натолкнуло меня на комбинаторное решение текущей задачи.

По сути, что нам надо сделать.
У нас есть $N$ цифр-позиций (6, но может быть и меньше).
В эти позиции надо разместить цифры из набора размера $K$ (от какого-то начального до 9).
Эта задача эквивалентна задаче размещения $N$ идентичных шаров по $K$ упорядоченным коробкам, которая решается методом "шаров и перегородок".

Суть метода в том, что содержимое каждой "коробки" отделяется от других "коробок" перегородками.
Всего нам нужно разместить $K-1$ перегородку.
Объединим шары и перегородки в единый набор сущностей, после чего найдем число сочетаний $C_{N+K-1}^{K-1}$, то есть число способов выбрать $K-1$ перегородку из совокупности шаров-перегородок.

Функция `num` делает как раз именно это:

1. В функции происходит перебор всех вариантов размещения перегородок, для каждого из которых находится число шаров в соответствующей коробке.
   Для упрощения цикла подсчета (для устранения граничных случаев для первого и последнего элементов) к рассматриваемому на каждом шаге набору позиций добавляются $-1$ и $N$ в начале и конце, соответственно.
2. Полученный набор проверяется на соответствие условию правильности пароля `cond`.
   По умолчанию это наличие хоть одной цифры, которая встречается не менее 2 раз.
   Неубывание цифр проверять не нужно, так как оно обеспечивается построением ("коробки" упорядоченны).

Можно было бы захардкодить начальные и конечные границы для пароля, но это не наш метод.
Функция `count` вычисляет число валидных паролей от какого-то числа до 999999 (аргумент `digits` позволяет варьировать длину пароля).

1. Сначала мы разбираем число на цифры.
   Опять-таки, для избавления от граничных случаев добавляем в конец псевдо-цифру 9.

   * Если число цифр в числе меньше целевого, то просто возвращаем число паролей от 111111 до 999999.
   * Если больше - возвращаем 0.
     Очевидно, что валидных 6-значных паролей, начинающихся с 7-значного начального значения, не так уж и много.

2. Далее создаем пустой стек и начинаем анализировать цифры.

   * Если текущая цифра $d_0$ меньше или равна следующей (например $2\ 7****$), то запишем в стек кортеж из $d_0+1$ и числа цифр-позиций от текущей цифры до конца числа включительно.
     Это означает, что $d_0$ фактически зафиксирована следующей цифрой $d_1$, поэтому число валидных паролей равно числу валидных паролей длиной на единицу меньше (фактически мы фиксируем первую цифру и перебираем последующие), которое мы определим на следующем шаге, плюс числу валидных паролей текущей длины, но начинающихся с цифры $d_0+1$ (например $3*****$).
   * Если же $d_0$ **больше** $d_1$, то записываем в стек кортеж из $d_0$ и текущей длины и прекращаем разбор.
     Дальнейший разбор не нужен, так как первый валидный пароль $d_0\ d_0 \dots d_0$ уже больше, чем рассматриваемый хвост числа.
   * Если мы не остановили разбор, то есть реализовалась первая ситуация, то переходим к следующей цифре $d_1$.
     Длина рассматриваемого отрезка, хвоста числа, уменьшается на 1.

3. После заполнения стека последовательно возвращаем верхнее значение, получаем из него первую цифру диапазона (от этой цифры до 9), число цифр-позиций.
   После чего считаем число валидных паролей функцией `num` и прибавляем к аккумулятору.
   Повторяем до исчерпания стека.

Итоговый ответ равен разнице числа валидных паролей от начала диапазона и от его конца.
Напомним, функция `count` считает число паролей до 999999.

## День 14

Залез на Реддит только для того, чтобы убедиться, что мое решение было правильным.

Но с ошибкой :smile:

Собака была зарыта в попытке сделать функцию способной быть примененной в цепном вызове,
то есть когда вывод предыдущего вызова передавался на вход следующего.
Для этого одному из аргументов функции задавалось значение по умолчанию `defaultdict(int)`.

Все бы хорошо, но я внезапно вспомнил, что значения по умолчанию инициализируются на в момент вызова функции,
что приводило бы к пересозданию **мутабельного** объекта, а в момент создания объекта функции,
что происходит во время обработки ее кода.
То есть все вызовы функции оперируют **одним и тем же объектом**!

То есть в моем случае вместо пустого словаря в функции болтался какой-то мусор.
После исправления ошибки все пошло как по маслу.

Логика первой части проста, но заковыриста.
Мы отслеживаем объемы производства каждого из ингредиентов и остающиеся излишки.
Излишки возникают по причине того, что мы не всегда можем произвести нужное количество за целое число реакций.

Создадим

* словари для объемов производства и излишков;
* очередь для обработки объемов производства.

Запишем в очередь кортеж `("FUEL", n)`, где `n` --- нужное количество топлива.
Пока очередь не пуста, повторяем следующую процедуру:

1. Забираем из очереди первый элемент: ингредиент и его необходимое количество `V`.
   Так как один ингредиент может участвовать в разных реакциях, то он может попадать в очередь несколько раз.
2. Если ингредиентом является руда, то просто увеличивем объемы производства в соответствующем словаре на `V` и переходим к пункту 1.
2. Вычитаем из `V` объемы излишков данного ингредиента (они могут быть если мы ранее уже производили данный ингредиент).
   Находим частное и остаток от деления полученного объема на объем производства ингредиента в соответствующей реакции.
3. Если остаток

   * равен нулю, значит мы можем произвести целым числом реакций объем `V` за вычетом излишков.
     Приравняем излишки нулю.
   * больше нуля, то увеличиваем частное на 1, так как нам понадобится дополнительная реакция для произодства данного остатка.
     Излишки приравняем к объему производства (произведению частного на объем производства в реакции) за вычетом требуемого объема производства, уменьшенного на величину излишков.

4. После чего последовательно добавляем в очередь кортежи из названий новых ингредиентов (берем из реакции для производства текущего) и их требуемых объемов, умноженных на частное из пункта 2.
   Увеличиваем объемы производства ингредиента в соответствующем словаре на произведение частного из пункта 2 на объем производства в реакции.

После опустошения очереди возвращаем из словаря объемов производства значение для руды.

Во второй части воспользуемся методом, близким по духу к [методу Ньютона](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%9D%D1%8C%D1%8E%D1%82%D0%BE%D0%BD%D0%B0).
Отметим, что из-за наличия излишков, $Ore(N) \leqslant N \times Ore(1)$, где $Ore(N)$ --- минимальный объем руды для производства $N$ единиц топлива.
Алгоритм следующий.

1. Найдем $Ore(1)$ и используем это значение для получения нижней границы ответа $$N_0 = \lfloor Ore_{max} / Ore(1) \rfloor$$
   Эта граница будет заведомо меньше правильного результата.
   Примем $N_0$ в качестве начального значения.
2. Найдем $Ore(N_i)$.

   * Если это значение будет больше, чем $Ore_{max}$, то ответом будет $N_{i-1}$.
   * Иначе найдем разницу
     $$\Delta Ore = Ore_{max} - Ore(N_i)$$
     целочисленно разделим ее на $Ore(1)$
     $$\Delta N = \lfloor \Delta Ore / Ore(1) \rfloor$$
     и увеличим $N$ на полученный результат или на 1, если он равен нулю
     $$N_{i+1} = N_i + \max \{\Delta N, 1\}$$

## День 16

Первая часть довольно простая, но нужно аккуратно работать с индексами.

Вторая часть гораздо сложнее. Я ее решил только с помощью Реддита.
У меня в мозгу появлялась идея матриц, но я ее обдумывал в неправильном направлении.

Решение основывается на той идее, что величина смещения в данных заведомо переводит нас во вторую половину длинного числа (исходное число, повторенное 10000 раз).
А если проанализировать правило, по которому происходит суммирование, то станет ясно, что все цифры во второй половине числа строятся на основании паттерна, состоящего из нулей в начале (вплоть до позиции искомой цифры) и единиц после (вплоть до конца числа).

Собственно, это все объяснение решения.

## День 18

Я задачу и решил, и не решил.

Первая часть довольно простая и представляет собой алгоритм Дейкстры, где в качестве состояния надо хранить позицию и набор найденных ключей.

Вторая часть, строго говоря, тоже представляет собой алгоритм Дейкстры, в котором теперь надо хранить четыре позиции и список ключей.
В остальном, в принципе, все то же самое.

Кроме того факта, что работает все адски медленно.
Я поставил эту задачу решаться на ночь, но компьютер ушел в гибернацию **до** получения ответа.
Причем после пробуждения я обнаружил, что программа забила всю память!
Хотя, справедливости ради, на маленьких примерах все работает.
Видимо размер реальной задачи требет оптимизации.

Идею подсмотрел у [u/bla2](https://www.reddit.com/r/adventofcode/comments/ec8090/comment/fbdtmks/).
Смысл ее в том, что кратчайший путь мы так же ищем при помощи алгоритма Дейкстры, причем более-менее таким же, что и у меня.
Единственное, но существенное отличие состоит в том, что в нем мы ходим не по одной клеточке, а сразу между ключами!
Для этого используется функция-генератор, которая последовательно возвращает все достижимые из текущего состояния ключи.
Используется обход в ширину, что дает нам какой-нибудь **кратчайший** путь до каждого достижимого ключа.

# День 19

Задача довольно простая.

Первую часть решил простым перебором всех координат.
Думаю, что можно использовать вторую часть для ускорения (да, можно, работает гораздо быстрее).

Во второй части я строил словарь, где для каждого значения `y` сохранял левую (включительно) и правую (не включительно) границы луча.
После чего просто проверял допустимость координат `x0` и `x1` для `y` и `y-99` соответственно.
