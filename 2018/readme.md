# Заметки к задачам 2018 года

## День 14

В данной задаче нет нужды искать подстроку (подсписок) в итоговой строке или списке.
Достаточно искать вхождение искомого результата в хвосте итоговой строки или списка.

Решение со строкой в моем случае не работает за разумное время.
Со списком работает за 18-20 секунд.

## День 15

Решил задачу я сам, но скелет подсмотрел в решении [u/sciyoshi](https://www.reddit.com/r/adventofcode/comments/a6chwa/comment/ebtwcqr).
Не очень честно, но зато научился делать классы, расширяющие другие классы.

1. В коде используется хитрый прием, который раньше мне не приходил даже в голову.
   Вообще в Python, как мне помнится, нельзя использовать конструктор класса внутри определения класса, так как на момент определения класса он неизвестен окружению.
   Но, что было для меня откровением, `type(obj)` возвращает не строку, а объект типа `type`, который можно использовать как конструктор класса, совпадающего с классом `obj`!

   ```python
   x = 3  # int
   type(x)  # -> int
   type(x)(1.9)  # -> 1
   ```

2. Надо внимательно читать условие.
   Написано, что если при поиске следующего шага у эльфа или гоблина имеется **несколько** вариантов путей, то он выбирает первый шаг по принципу "слева-направо и сверху-вниз".
   Единственное **но**: выбор производится на базе финальной точки маршрута, а не начальной (первой после старта!).

3. И преждевременная оптимизация (замена соседних с целью точек на саму цель) как всегда оказалась вредной и ненужной!

## День 17

Код в файле `part1.py` работает на тестовых данных, но на итоговых данных код не работает (точнее я не дождался окончания).

Подсмотрел на реддите у [u/sciyoshi](https://www.reddit.com/r/adventofcode/comments/a6wpup/comment/ebyq6mj) решение через рекурсию.
Идея о применении рекурсии меня посещала, но я ее, как обычно, не развил.

Решение можно описать следующим образом:

1. Вода течет **только вниз**.
   Если вниз вода не течет, то пытаемся течь вбок.
2. Вода растекается **только** по глине и **стоячей** воде.
   То есть после того, как нижняя ячейка будет заполнена -- после завершения первого рекурсивного вызова -- следует провести проверку на то, является ли вода в нижней ячейке стоячей.
   Если вода не стоячая, то возвращаем значение `False`.
3. Если же вода начала растекаться (допустим влево), то смотрим:
   * являетя ли следующая ячейка глиной,
   * или она еще не заполнена водой, и при дальнейшем рекурсивном заполнении мы не провалимся вниз.
   Если одно из этих условий истинно, то отмечаем рассматриваемое направление как **заблокировнное**.
4. Если **оба** направления заблокированы, то мы находимся в резервуаре.
   Начинаем отмечать все ячейки в нем как заполненные **стоячей** водой.
5. Возвращаем `True`, если хотя бы одно направление было определено как заблокированное.
   Это может показаться нелогичным, но надо заметить, что при растекании (см. пункт 3) вода течет только в одном направлении, так как в обратную сторону вода течь не сможет (мы проверяем ячейку на незаполненность водой!).
   Так что в точке начала растекания, при условии, что мы находимся в резервуаре, **обе** ветви вернут значение `True`.

## День 20

Решение подсмотрел у [u/mrFred489](https://www.reddit.com/r/adventofcode/comments/a7uk3f/comment/ec61vb0).

Не надо было опираться на прошлый опыт.
Рекурсия не дает нужного результата, а если и дает, то очень медленно.

Выяснил, что иногда рекурсивные задачи проще решать через стек.
И не всегда нужно полностью обрабатывать ввод перед переходом к решению задачи.
Иногда проще решать одновременно с обработкой ввода.

Обидно, что в очередной раз отдельные части решения приходили мне в голову, но знаний не хватило их скрестить между собой.

## День 21

Ну вот опять, идея с циклом мне в голову пришла, но я ее не додумал...

В данной задаче не нужно понимать (досконально), чего пытается достичь код.
Магические числа подобраны так, чтобы это было бессмысленно.

В первой части надо понять, что мы должны выйти из кода при первом выполнении команды `eqrr`.
Ответом будет значение в регистре `r5`.

Во второй части я был близок к идее цикла, но не додумал.
Действительно, значение в регистре `r5` **строго ограничено**!
Тем самым можно прийти к выводу, что рано или поздно код свалится в цикл.

Более того, в начале каждого внутреннего цикла в коде (`ip == 6`), нам нужно только значение `r5`, так как остальные получаются из него.
Остальное просто...

P.S. Книжку по алгоритмам я купил, буду учиться...

## День 23

Первая часть крайне проста.

Вторая оказалась дстаточно сложной.
Я дошел до главной идеи: найти область с максимальным пересечением.
Проблемой оказалось понять, как найти эту область, да еще и в трехмерном пространстве.

### Быстрое, но некорректное решение

Крайне интересный подход у [u/EriiKKo](https://www.reddit.com/r/adventofcode/comments/a8s17l/comment/ecdqzdg):

1. Преобразуем трехмерный массив наноботов в одномерный, содержащий минимальное и максимальное расстояние до начала координат.
   Также учтем начало и конец полученного интервала (1 и -1, соответсвенно).
2. Отсортируем полученный список по возрастанию расстояния.
3. Отсекая по одному элементу находим расстояние до максимального пересечения.

Однако следует признать, что этот подход, в общем случае, неверен.
Это признает и сам автор.

### Корректное, но более медленное решение

[u/fizbin](https://www.reddit.com/r/adventofcode/comments/a8s17l/comment/ecfmpy0) использовал подход, который предполагался **автором** AoC [u/topaz2078](https://www.reddit.com/r/adventofcode/comments/aa9uvg/comment/ecrftas).

1. Найдем максимальное **абсолютное** значение координат бота плюс его радиус.
2. Найдем минимальный размер куба, который будет включать **все** боты с их радиусами.
3. Создадим очередь с приоритетом, в которой
   * сначала будем учитывать число пересечений куба с ботами (то есть их областями) с минусом (для превращения максимума в минимум);
   * затем будем рассматривать размер куба, также с минусом, чтобы в спорных ситуациях обрабатывать в первую очередь более крупные куски;
   * после будем учитывать расстояние от *нижнего* угла до стартовой позиции;
   * хранить будем сам куб, который определяется двумя точками, условно (0, 0, 0) и (1, 1, 1).
4. На каждом шаге будем брать первый элемент из очереди.
   Полученный куб будем делить на восемь равных кусков, для каждого из которых находим число пересечений с областями ботов и расстояние до старта.
   Добавляем новые кубы (**октанты**) в очередь.
5. Повторяем шаг 4 до тех пор, пока размер очередного куба не будет равен 1.
   Так как мы работаем с очередью с приоритетом, то мы можем быть уверенными, что мы получили результат.
