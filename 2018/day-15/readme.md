# Заметки

Решил задачу я сам, но скелет подсмотрел в решении [u/sciyoshi].
Не очень честно, но зато научился делать классы, расширяющие другие классы.

1. В коде используется хитрый прием, который раньше мне не приходил даже в голову.
   Вообще в Python, как мне помнится, нельзя использовать конструктор класса внутри определения класса, так как на момент определения класса он неизвестен окружению.
   Но, что было для меня откровением, `type(obj)` возвращает не строку, а объект типа `type`, который можно использовать как конструктор класса, совпадающего с классом `obj`!

   ```python
   x = 3  # int
   type(x)  # -> int
   type(x)(1.9)  # -> 1
   ```

2. Надо внимательно читать условие.
   Написано, что если при поиске следующего шага у эльфа или гоблина имеется **несколько** вариантов путей, то он выбирает первый шаг по принципу "слева-направо и сверху-вниз".
   Единственное **но**: выбор производится на базе финальной точки маршрута, а не начальной (первой после старта!).

3. И преждевременная оптимизация (замена соседних с целью точек на саму цель) как всегда оказалась вредной и ненужной!
