# Заметки

Решил не сам, пользовался подсказками на реддите:

1. [Первое решение](https://www.reddit.com/r/adventofcode/comments/18qbsxs/comment/keubcfd) использует [вектор Фидлера](https://en.wikipedia.org/wiki/Algebraic_connectivity#Partitioning_a_graph_using_the_Fiedler_vector).
   Данное решение самое медленное, так как требует создания матрицы размером, равным числу узлов в графе.
2. Второе решение основано на алгоритме Каргера. Я и сам хотел его реализовать но не мог придумать, как эффективно хранить информацию о слиянии узлов. В каком-то из постов (не нашел в каком) увидел решение: надо хранить в словаре для каждого узле не только список соседей, но и список слитых узлов.
   Во время слияния двух соседних узлов все соседи второго переносятся в список соседей первого узла (причем с сохранением дубликатов!), после чего второй узел удаляется из графа.
3. Третье простое и [интересное решение](https://www.reddit.com/r/adventofcode/comments/18qbsxs/comment/ketzp94) основано на идее, что граф делится на две половины, причем принадлежность вершины той или иной половине определяется приналежностью большинства ее непосредственных соседей.
   Сначала все вершины находятся в одной половине; на каждом шаге вершина с максимальным числом соседей в другой половине (на первом шаге любая) переносится в нее (удаляется из списка вершин **этой** половины).
   Процесс продолжается до тех пор, пока суммарное количество соседних вершин в **другой** половине не станет равным 3.
