# Заметки к задачам 2023 года

## День 1

Первая часть: ОК!

Вторая часть: WTF!!! Я даже не буду посыпать себе голову пеплом, так
формулировать условия задачи --- свинство. Да, можно сидеть и
просматривать 1000 строк входных данных, но даже в этом случае ответ НЕ
ОЧЕВИДЕН!

## День 5

Мда, задача для меня оказалась сложновата, надо подтягивать математику и
алгоритмы.
Решить вторую часть смог только с помощью реддита.

Алгоритм сам по себе оказался несложен:

1. Берем первый диапазон семян (ДС).
2. Находим отображение первого шага, для которого есть пересечение
   входного диапазона (ДВ) с ДС.
3. Полученное пересечение (его границы) отображаем и сохраняем для
   следующего шага.
4. Если от ДС остались кусочки, то сохраняем их для **текущего** шага.
5. Если пересечений не было вообще, то ДС переносится на следующий шаг.

## День 12

Надо подучить динамическое программирование, решил сам только первую
часть, и то брутфорсом. Я ее не включил, но там все очевидно:
перебираем числа от 0 до $2^N$ (N --- число ?), меняем 1 на # и
сравниваем с набором длин.

Вторую часть подсмотрел у [u/pred](https://www.reddit.com/r/adventofcode/comments/18ge41g/comment/kd0dw9e/).

## День 16

Подсмотрел идею на реддите. Смысл в том, что не надо на каждом шаге
добавлять следующий тайл в очередь. Достаточно обновлять координаты. В
очередь нужно добавлять ТОЛЬКО один из вариантов развлетвления.
Таким образом мы минимизируем запись/чтение из списка --- достаточно
медленные операции.

## День 21

Решение не моё, а честно стыренное на Реддите.
Но я честно попытался его осознать.

Обозначим решение для $n$ шагов как $f(n)$.

Ключевая идея решения состоит в том, что *S* находится **строго** в центре карты, а соответствующие строка и столбец пустые.
Также пустыми являются края карты.

Это означает, что переход из *S* в любую соседнюю копию карты происходит минимум за $r = \lfloor X / 2 \rfloor$ и максимум за $X$ шагов, где $X$ --- длина стороны карты.
Она кстати, квадратная.

Обратим внимание, что число шагов в условии равно $q \times X + r$.

При $q = 0$ мы находим решение **только** для стартового или любого другого квадрата.
Одного квадрата.

Если же $q = 1$, то, учитывая пустые края и центр (примыкающий к *S*) карты, за $X$ шагов мы доходим до центра одного из квадратов и за $r$ шагов находим число решений в нем.
На момент достижения центра сторона квадрата, ограниченного фронтом потенциальных точек будет иметь длину, которую мы приравняем к $1$, а его площадь, соответственно, также будет равна$1$.
Оставшиеся $r$ шагов обходим квадраты.

Очевидно, что при $q = 2$ мы обойдем 25 квадратов, а фронт на момент достижения центрова будет иметь длину стороны $2$ и площадь $4$.
И так далее.

Таким образом, последовательность $f(r), f(r+X), f(r+2X), \dots$ представляет собой точки на некоторой параболе, которую надо восстановить по трем точкам и найти ее значение в точке $q$.

Подробнее в видео [u/Boojum](https://www.reddit.com/r/adventofcode/comments/18njrqf/2023_day_21_a_diamond_in_the_rough/)

## День 25

Решил не сам, пользовался подсказками на реддите:

1. [Первое решение](https://www.reddit.com/r/adventofcode/comments/18qbsxs/comment/keubcfd) использует [вектор Фидлера](https://en.wikipedia.org/wiki/Algebraic_connectivity#Partitioning_a_graph_using_the_Fiedler_vector).
   Данное решение самое медленное, так как требует создания матрицы размером, равным числу узлов в графе.
2. Второе решение основано на алгоритме Каргера. Я и сам хотел его реализовать но не мог придумать, как эффективно хранить информацию о слиянии узлов. В каком-то из постов (не нашел в каком) увидел решение: надо хранить в словаре для каждого узле не только список соседей, но и список слитых узлов.
   Во время слияния двух соседних узлов все соседи второго переносятся в список соседей первого узла (причем с сохранением дубликатов!), после чего второй узел удаляется из графа.
3. Третье простое и [интересное решение](https://www.reddit.com/r/adventofcode/comments/18qbsxs/comment/ketzp94) основано на идее, что граф делится на две половины, причем принадлежность вершины той или иной половине определяется приналежностью большинства ее непосредственных соседей.
   Сначала все вершины находятся в одной половине; на каждом шаге вершина с максимальным числом соседей в другой половине (на первом шаге любая) переносится в нее (удаляется из списка вершин **этой** половины).
   Процесс продолжается до тех пор, пока суммарное количество соседних вершин в **другой** половине не станет равным 3.
